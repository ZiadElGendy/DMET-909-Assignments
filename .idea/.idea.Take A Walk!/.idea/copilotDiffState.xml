<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/MovementController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/MovementController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;[RequireComponent(typeof(CharacterController))]&#10;public class MovementController : MonoBehaviour&#10;{&#10;    private static readonly int IsMoving = Animator.StringToHash(&quot;isMoving&quot;);&#10;&#10;    [Header(&quot;Settings&quot;)]&#10;    [SerializeField] public float speed = 5f;&#10;&#10;    [Header(&quot;References&quot;)]&#10;    [SerializeField] private CharacterController controller;&#10;    [SerializeField] private Animator animator; // Animator to set IsMoving&#10;    [SerializeField] private SpriteRenderer spriteRenderer; // optional: sprite to flip when moving left/right&#10;&#10;    private float _gravity = -9.81f;&#10;    private Vector3 _velocity;&#10;&#10;    void Start()&#10;    {&#10;        // Auto-assign CharacterController if not set in inspector&#10;        if (controller == null)&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;        // Auto-assign Animator if not set&#10;        if (animator == null)&#10;            animator = GetComponent&lt;Animator&gt;();&#10;&#10;        // Auto-assign SpriteRenderer if not set (search children)&#10;        if (spriteRenderer == null)&#10;            spriteRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;();&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        if (controller == null) return;&#10;&#10;        // Read raw input (legacy Input system kept as in original)&#10;        float moveX = Input.GetAxis(&quot;Horizontal&quot;);&#10;        float moveZ = Input.GetAxis(&quot;Vertical&quot;);&#10;&#10;        // Determine camera-relative axes (fall back to player transform if no camera)&#10;        Transform cam = Camera.main != null ? Camera.main.transform : null;&#10;        Vector3 camForward = cam != null ? cam.forward : transform.forward;&#10;        Vector3 camRight = cam != null ? cam.right : transform.right;&#10;&#10;        // Flatten to horizontal plane and normalize&#10;        camForward.y = 0f;&#10;        camRight.y = 0f;&#10;        camForward.Normalize();&#10;        camRight.Normalize();&#10;&#10;        // Calculate movement direction relative to camera&#10;        Vector3 move = camRight * moveX + camForward * moveZ;&#10;&#10;        // Prevent faster diagonal movement&#10;        if (move.sqrMagnitude &gt; 1f)&#10;            move.Normalize();&#10;&#10;        // Update Animator parameter&#10;        bool isMoving = move.sqrMagnitude &gt; 0.0001f;&#10;        if (animator != null)&#10;            animator.SetBool(IsMoving, isMoving);&#10;&#10;        // Flip sprite based on lateral movement relative to camera&#10;        if (spriteRenderer != null &amp;&amp; isMoving)&#10;        {&#10;            // lateral &gt; 0 means moving to camera's right, lateral &lt; 0 means left&#10;            float lateral = Vector3.Dot(move.normalized, camRight);&#10;            // If lateral is negative, face left (flipX true), else face right&#10;            spriteRenderer.flipX = lateral &lt; 0f;&#10;        }&#10;&#10;        // Move the character horizontally&#10;        Vector3 horizontalMove = move * speed;&#10;        controller.Move(horizontalMove * Time.deltaTime);&#10;&#10;        // Reset vertical velocity when grounded&#10;        if (controller.isGrounded &amp;&amp; _velocity.y &lt; 0f)&#10;        {&#10;            _velocity.y = -2f;&#10;        }&#10;&#10;        // Apply gravity&#10;        _velocity.y += _gravity * Time.deltaTime;&#10;        controller.Move(_velocity * Time.deltaTime);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;#if ENABLE_INPUT_SYSTEM&#10;using UnityEngine.InputSystem;&#10;#endif&#10;&#10;[RequireComponent(typeof(CharacterController))]&#10;public class MovementController : MonoBehaviour&#10;{&#10;    private static readonly int IsMoving = Animator.StringToHash(&quot;IsMoving&quot;);&#10;&#10;    [Header(&quot;Settings&quot;)]&#10;    [SerializeField] public float speed = 5f;&#10;&#10;    [Header(&quot;References&quot;)]&#10;    [SerializeField] private CharacterController controller;&#10;    [SerializeField] private Animator animator; // Animator to set IsMoving&#10;    [SerializeField] private SpriteRenderer spriteRenderer; // optional: sprite to flip when moving left/right&#10;&#10;    private float _gravity = -9.81f;&#10;    private Vector3 _velocity;&#10;&#10;#if ENABLE_INPUT_SYSTEM&#10;    private InputAction moveAction;&#10;#endif&#10;&#10;    void Start()&#10;    {&#10;        // Auto-assign CharacterController if not set in inspector&#10;        if (controller == null)&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;        // Auto-assign Animator if not set&#10;        if (animator == null)&#10;            animator = GetComponent&lt;Animator&gt;();&#10;&#10;        // Auto-assign SpriteRenderer if not set (search children)&#10;        if (spriteRenderer == null)&#10;            spriteRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;();&#10;&#10;#if ENABLE_INPUT_SYSTEM&#10;        // Build a simple Move action that supports WASD/arrow keys and gamepad left stick&#10;        moveAction = new InputAction(&quot;Move&quot;, InputActionType.Value);&#10;        // Keyboard 2D composite (WASD)&#10;        moveAction.AddCompositeBinding(&quot;2DVector&quot;)&#10;            .With(&quot;Up&quot;, &quot;&lt;Keyboard&gt;/w&quot;)&#10;            .With(&quot;Down&quot;, &quot;&lt;Keyboard&gt;/s&quot;)&#10;            .With(&quot;Left&quot;, &quot;&lt;Keyboard&gt;/a&quot;)&#10;            .With(&quot;Right&quot;, &quot;&lt;Keyboard&gt;/d&quot;);&#10;        // Arrow keys&#10;        moveAction.AddCompositeBinding(&quot;2DVector&quot;)&#10;            .With(&quot;Up&quot;, &quot;&lt;Keyboard&gt;/upArrow&quot;)&#10;            .With(&quot;Down&quot;, &quot;&lt;Keyboard&gt;/downArrow&quot;)&#10;            .With(&quot;Left&quot;, &quot;&lt;Keyboard&gt;/leftArrow&quot;)&#10;            .With(&quot;Right&quot;, &quot;&lt;Keyboard&gt;/rightArrow&quot;);&#10;        // Gamepad left stick&#10;        moveAction.AddBinding(&quot;&lt;Gamepad&gt;/leftStick&quot;);&#10;&#10;        moveAction.Enable();&#10;#endif&#10;    }&#10;&#10;    void OnEnable()&#10;    {&#10;#if ENABLE_INPUT_SYSTEM&#10;        if (moveAction != null)&#10;            moveAction.Enable();&#10;#endif&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;#if ENABLE_INPUT_SYSTEM&#10;        if (moveAction != null)&#10;            moveAction.Disable();&#10;#endif&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        if (controller == null) return;&#10;&#10;        // Read input either from the new Input System (if enabled) or fall back to legacy Input&#10;        float moveX = 0f;&#10;        float moveZ = 0f;&#10;&#10;#if ENABLE_INPUT_SYSTEM&#10;        if (moveAction != null)&#10;        {&#10;            Vector2 mv = moveAction.ReadValue&lt;Vector2&gt;();&#10;            moveX = mv.x;&#10;            moveZ = mv.y;&#10;        }&#10;        else&#10;        {&#10;            moveX = Input.GetAxis(&quot;Horizontal&quot;);&#10;            moveZ = Input.GetAxis(&quot;Vertical&quot;);&#10;        }&#10;#else&#10;        moveX = Input.GetAxis(&quot;Horizontal&quot;);&#10;        moveZ = Input.GetAxis(&quot;Vertical&quot;);&#10;#endif&#10;&#10;        // Determine camera-relative axes (fall back to player transform if no camera)&#10;        Transform cam = Camera.main != null ? Camera.main.transform : null;&#10;        Vector3 camForward = cam != null ? cam.forward : transform.forward;&#10;        Vector3 camRight = cam != null ? cam.right : transform.right;&#10;&#10;        // Flatten to horizontal plane and normalize&#10;        camForward.y = 0f;&#10;        camRight.y = 0f;&#10;        camForward.Normalize();&#10;        camRight.Normalize();&#10;&#10;        // Calculate movement direction relative to camera&#10;        Vector3 move = camRight * moveX + camForward * moveZ;&#10;&#10;        // Prevent faster diagonal movement&#10;        if (move.sqrMagnitude &gt; 1f)&#10;            move.Normalize();&#10;&#10;        // Update Animator parameter&#10;        bool isMoving = move.sqrMagnitude &gt; 0.0001f;&#10;        if (animator != null)&#10;            animator.SetBool(IsMoving, isMoving);&#10;&#10;        // Flip sprite based on lateral movement relative to camera&#10;        if (spriteRenderer != null &amp;&amp; isMoving)&#10;        {&#10;            // lateral &gt; 0 means moving to camera's right, lateral &lt; 0 means left&#10;            float lateral = Vector3.Dot(move.normalized, camRight);&#10;            // If lateral is negative, face left (flipX true), else face right&#10;            spriteRenderer.flipX = lateral &lt; 0f;&#10;        }&#10;&#10;        // Move the character horizontally&#10;        Vector3 horizontalMove = move * speed;&#10;        controller.Move(horizontalMove * Time.deltaTime);&#10;&#10;        // Reset vertical velocity when grounded&#10;        if (controller.isGrounded &amp;&amp; _velocity.y &lt; 0f)&#10;        {&#10;            _velocity.y = -2f;&#10;        }&#10;&#10;        // Apply gravity&#10;        _velocity.y += _gravity * Time.deltaTime;&#10;        controller.Move(_velocity * Time.deltaTime);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>